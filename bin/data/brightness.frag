#version 410

uniform sampler2D parrotTex; // 오픈프레임웍스의 draw() 루프에서 전송해 준 텍스쳐 이미지를 저장할 유니폼 변수
uniform float brightness;

in vec2 fragUV; // 버텍스 셰이더에서 out 키워드로 전송해 준 uv좌표 데이터(각 프래그먼트마다 보간되서 넘어옴)
out vec4 outColor; // 결과값으로 계산된 프래그먼트 색상을 다음 파이프라인으러 넘겨주는 변수

void main(){
  // vec4 tex = texture(parrotTex, fragUV); // 보간된 uv좌표로 앵무새 텍스쳐를 샘플링하여 텍셀값을 가져옴.
  
  // 텍셀값의 각 채널(r, g, b, a) 에 동일한 float 값 2.0 을 곱해주면
  // 해당 텍셀값, 즉 색상값의 밝기값이 증가하게 됨. -> 렌더링되는 텍스쳐 이미지의 전체 밝기값이 증가하겠지
  // 이런 식으로 색상의 밝기값을 조절하려면 색상값의 각 채널을 '동일한 값'으로 곱해주면 됨!
  // 이때, vec4 타입 변수 컴포넌트를 x, y, z, w 가 아닌, r, g, b, a 로 접근할 수도 있음.
  // 왜냐하면, 셰이더 코드는 색상값을 벡터에 저장하는 경우가 흔하기 때문에, glsl 이 편의상 제공하는 기능이라고 보면 됨.
  // tex.r *= 2.0f;
  // tex.g *= 2.0f;
  // tex.b *= 2.0f;
  // tex.a *= 2.0f; // 참고로 2.0 뒤에 f 안붙여도 동일한 결과가 나옴.

  // 근데 밝기값 하나 조절하는데 위에 쓴 코드의 양이 너무 많으니,
  // 벡터의 스칼라곱, 즉 벡터 하나에 어떤 스칼라 실수값을 곱하면,
  // 벡터 내부의 각 컴포넌트들에 일률적으로 해당 스칼라값이 곱해진다는 성질을 이용해서,
  // 리턴받은 텍셀값인 vec4 자체에 2.0 을 곱해주면 아래와 같이 한줄로 코드를 정리할 수 있음.
  // outColor = texture(parrotTex, fragUV) * 2.0f;

  // 이제 cpp, 즉, 오픈프레임웍스에서 값을 전달해준 유니폼 변수를 이용해서
  // 밝기값을 조절할 수 있도록 유니폼 변수 brightness 를 생성하여 텍셀값 vec4 에 스칼라곱을 해줌.
  outColor = texture(parrotTex, fragUV) * brightness;
}