#version 410 // 셰이더 코드는 항상 glsl 버전을 명시하고서 시작해야 함.

// ofApp.cpp 의 setup() 함수에서 위치와 색상, 즉 여러 개의 vertex attribute 를 지정했으므로, layout 으로 받아오는 키워드들의 종류를 구분할 것!
layout(location = 0) in vec3 position;
layout(location = 3) in vec2 uv; // setup() 함수에서 추가해 준 uv좌표 데이터를 받아올 변수!

/*
  glsl 은 시간값을 알려주는 개념이 없기 때문에,
  c++ 단에서, 즉 오픈프레임웍스 함수를 활용해서 
  프로그램 실행 이후 경과된 시간값을 셰이더에 전송해줘야 함.

  (마치 webgl 에서 셰이더의 시간값 전송받을 때 
  requestAnimationFrame() 의 콜백함수에서 사용하는 
  타임스탬프값을 glsl 로 전송해주는 것과 똑같음.
  
  어쨋든, cpu 단에서 돌아가는 언어들(cpp, js, webgl, opengl 등)
  에서 경과된 시간값을 쏴줘야 셰이더에 애니메이션 효과를 적용할 수 있음.)

  시간값은 동일한 시간대 내의 모든 프래그먼트 및 버텍스, 파이프라인에서
  똑같이 적용되므로, uniform 변수로 받으면 됨.

  또, 시간값은 float 1개의 값만으로 받으면 되니
  데이터타입을 float 으로 지정함. 
*/
uniform float time;

out vec2 fragUV; // uv좌표 데이터를 out 키워드를 이용해 프로그먼트 셰이더로 넘겨줄 변수를 지정함.

void main() {
  gl_Position = vec4(position, 1.0);

  /*
    uv좌표값의 수직 방향 컴포넌트, 즉 y값을
    뒤집어서 전달해줘야 이미지가 위아래로 뒤집어지지 않고 똑바로 렌더링됨.
  */
  // fragUV = vec2(uv.x, 1.0 - uv.y) + vec2(0.25, 0.0);

  /*
    텍스쳐에 애니메이션을 적용하려면, 
    (0.25, 0.0) 같은 특정 벡터를 더해주는 게 아닌,
    vec2(1.0, 0.0) 처럼 정규화된 벡터를 uv좌표에 더해줄거임.

    이 정규화된 좌표에 시간 경과에 따라 값이 변하는 
    유니폼 변수인 time 을 곱해줌으로써,
    시간에 따라 vec2(N, 0.0) 값을 uv좌표에 더해줄 수 있음.

    이렇게 되면, 시간 경과에 따라 달라지는 time 값에 따라
    N 값도 점점 늘어나게 되겠지.
    1.0, 1.1, 1.2,..., 9.8, 9.9, 10.0, 10.1, 10.2,... 이런 식으로!

    그런데, 우리가 0 ~ 1 사이의 유효범위 uv좌표값을 넘어가는
    좌표에 대해서는 GL_REPEAT 모드로 gpu 가 처리할 수 있도록 해줬지?

    즉, (1.25, 0.0) 이라는 uv좌표로 샘플링을 시도하면,
    gpu는 얘를 (0.25, 0.0) 으로 변환해서 텍셀값을 샘플링해준다고 했잖아!

    그러니까, 위에 처럼 N의 정수값이 1, 2, 3,..., 9, 10,... 이렇게 바뀌어도
    결국 (0.x, 0.0) 요렇게 uv좌표를 변환해서 샘플링해준다는 것이지!

    그렇기 때문에, 아무리 시간이 지나더라도 텍스쳐를 반복해서
    샘플링해주게 될 것이고, time 값이 매 프레임마다 달라질테니까,
    매 프레임마다 샘플링된 텍스쳐가 계속 왼쪽으로 움직이는 듯한
    스크롤링 애니메이션 효과를 볼 수 있게 되는 것이지!  
  */
  fragUV = vec2(uv.x, 1.0 - uv.y) + vec2(1.0, 0.0) * time;
}

/*
  텍스쳐 랩 모드(wrap mode)

  webgl 공부할 때에도 다루긴 했었는데,
  랩 모드를 간단하게 표현하면,

  '프래그먼트 셰이더에서 0 ~ 1의 유효범위를 벗어나는 uv좌표값으로 
  텍스쳐 샘플링을 시도할 때, 텍스쳐가 대응하는 방식'
  
  을 그래픽 용어로는 '랩 모드' 라고 표현하는 것임.

  즉, 위에처럼, 프래그먼트 셰이더로 전달하는 uv좌표값들에 각각 x 컴포넌트에
  0.25씩 더해준다면, x컴포넌트 부분의 uv좌표 범위는 0.25 ~ 1.25 사이가 되겠지.

  이처럼 0 ~ 1 사이를 벗어나는 범위의 uv좌표값으로 텍스쳐 샘플링을 한다면,
  GPU 는 1.0 을 벗어나는 uv좌표값을 유효한 최대 텍스쳐 좌표값인 1.0 으로 고정해서
  처리해버린다는 뜻임.

  그렇기 때문에, uv좌표값이 1.0을 벗어나는 텍스쳐 샘플링에 대해서는,
  모두 1.0 지점에 해당하는 텍셀값을 샘플링해올 수밖에 없고,
  그래서 1.0을 벗어나는 지점부터는 마치 모서리가 늘어나는 듯한 효과를 줌.

  이러한 랩 모드 방식을 '고정(clamp) 모드' 라고 표현함. 
*/